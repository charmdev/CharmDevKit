// Generated by Haxe 4.0.0 (git build development @ a6f823f)
(function ($hx_exports) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.exists = function(it,f) {
	var x = $iterator(it)();
	while(x.hasNext()) if(f(x.next())) {
		return true;
	}
	return false;
};
Lambda.find = function(it,f) {
	var v = $iterator(it)();
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Sys = function() { };
Sys.__name__ = true;
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		return _g;
	}
};
var Vscode = require("vscode");
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_ArraySort = function() { };
haxe_ds_ArraySort.__name__ = true;
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g1 = from + 1;
		while(_g1 < to) {
			var j = _g1++;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,remove: function(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g1 = 1;
	var _g = paths1.length;
	while(_g1 < _g) {
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[_g1++];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	path = path.split("\\").join("/");
	if(path == "/") {
		return "/";
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split("/");
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join("/");
	var regex_r = new RegExp("([^:])/+","g".split("u").join(""));
	tmp.replace(regex_r,"$1" + "/");
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g11 = 0;
	var _g2 = tmp.length;
	while(_g11 < _g2) {
		var _g21 = tmp.charCodeAt(_g11++);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCharCode(_g21);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCharCode(_g21);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.isAbsolute = function(path) {
	if(StringTools.startsWith(path,"/")) {
		return true;
	}
	if(path.charAt(1) == ":") {
		return true;
	}
	if(StringTools.startsWith(path,"\\\\")) {
		return true;
	}
	return false;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		if(e.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				throw e;
			}
			if(!stat.isDirectory()) {
				throw e;
			}
		}
	}
};
var sys_io_File = function() { };
sys_io_File.__name__ = true;
sys_io_File.copy = function(srcPath,dstPath) {
	var src = js_node_Fs.openSync(srcPath,"r");
	var dst = js_node_Fs.openSync(dstPath,"w",js_node_Fs.fstatSync(src).mode);
	var bytesRead;
	var pos = 0;
	while(true) {
		bytesRead = js_node_Fs.readSync(src,sys_io_File.copyBuf,0,65536,pos);
		if(!(bytesRead > 0)) {
			break;
		}
		js_node_Fs.writeSync(dst,sys_io_File.copyBuf,0,bytesRead);
		pos += bytesRead;
	}
	js_node_Fs.closeSync(src);
	js_node_Fs.closeSync(dst);
};
var vscode_Disposable = require("vscode").Disposable;
var vscode_EventEmitter = require("vscode").EventEmitter;
var vscode_Location = require("vscode").Location;
var vscode_Position = require("vscode").Position;
var vscode_ProcessExecution = require("vscode").ProcessExecution;
var vscode__$ProgressLocation_ProgressLocation_$Impl_$ = require("vscode").ProgressLocation;
var vscode_Range = require("vscode").Range;
var vscode_Selection = require("vscode").Selection;
var vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$ = require("vscode").StatusBarAlignment;
var vscode_Task = require("vscode").Task;
var vscode_TaskGroup = require("vscode").TaskGroup;
var vscode_ThemeColor = require("vscode").ThemeColor;
var vscode_TreeItem = require("vscode").TreeItem;
var vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$ = require("vscode").TreeItemCollapsibleState;
var vscode_Uri = require("vscode").Uri;
var vshaxe_HxmlDiscovery = function(context) {
	var _gthis = this;
	this.context = context;
	this.files = context.workspaceState.get("haxe." + "hxmlDiscoveryFiles",[]);
	this._onDidChangeFiles = new vscode_EventEmitter();
	context.subscriptions.push(this._onDidChangeFiles);
	Vscode.workspace.findFiles("*.hxml").then(function(files) {
		var foundFiles = files != null ? files.map(function(uri) {
			return vshaxe_helper_PathHelper.relativize(uri.fsPath,Vscode.workspace.rootPath);
		}) : [];
		if(!vshaxe_helper_ArrayHelper.equals(_gthis.files,foundFiles)) {
			_gthis.files = foundFiles;
			_gthis.context.workspaceState.update("haxe." + "hxmlDiscoveryFiles",_gthis.files);
			_gthis._onDidChangeFiles.fire();
		}
		return;
	});
	var prefixedPattern = haxe_io_Path.join([Vscode.workspace.rootPath,"*.hxml"]);
	var fileWatcher = Vscode.workspace.createFileSystemWatcher(prefixedPattern,false,true,false);
	fileWatcher.onDidCreate(function(uri1) {
		_gthis.files.push(vshaxe_helper_PathHelper.relativize(uri1.fsPath,Vscode.workspace.rootPath));
		_gthis.context.workspaceState.update("haxe." + "hxmlDiscoveryFiles",_gthis.files);
		_gthis._onDidChangeFiles.fire();
		return;
	});
	fileWatcher.onDidDelete(function(uri2) {
		HxOverrides.remove(_gthis.files,vshaxe_helper_PathHelper.relativize(uri2.fsPath,Vscode.workspace.rootPath));
		_gthis.context.workspaceState.update("haxe." + "hxmlDiscoveryFiles",_gthis.files);
		_gthis._onDidChangeFiles.fire();
		return;
	});
};
vshaxe_HxmlDiscovery.__name__ = true;
var vshaxe_Main = function(context) {
	var displayArguments = new vshaxe_display_DisplayArguments(context);
	var haxeExecutable = new vshaxe_helper_HaxeExecutable(context);
	this.api = { haxeExecutable : haxeExecutable, registerDisplayArgumentsProvider : $bind(displayArguments,displayArguments.registerProvider), parseHxmlToArguments : vshaxe_helper_HxmlParser.parseToArgs};
	var server = new vshaxe_server_LanguageServer(context,haxeExecutable,displayArguments);
	new vshaxe_commands_Commands(context,server);
	new vshaxe_commands_InitProject(context);
	new vshaxe_dependencyExplorer_DependencyExplorer(context,displayArguments,haxeExecutable);
	var hxmlDiscovery = new vshaxe_HxmlDiscovery(context);
	new vshaxe_display_HaxeDisplayArgumentsProvider(context,this.api,hxmlDiscovery);
	new vshaxe_tasks_HxmlTaskProvider(hxmlDiscovery,haxeExecutable);
	server.start();
};
vshaxe_Main.__name__ = true;
vshaxe_Main.main = $hx_exports["activate"] = function(context) {
	return new vshaxe_Main(context).api;
};
var vshaxe_commands_Commands = function(context,server) {
	this.context = context;
	this.server = server;
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "restartLanguageServer",$bind(server,server.restart));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "applyFixes",$bind(this,this.applyFixes));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "showReferences",$bind(this,this.showReferences));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "runGlobalDiagnostics",$bind(this,this.runGlobalDiagnostics));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "toggleCodeLens",$bind(this,this.toggleCodeLens));
};
vshaxe_commands_Commands.__name__ = true;
vshaxe_commands_Commands.prototype = {
	applyFixes: function(uri,version,edits) {
		var editor = Vscode.window.activeTextEditor;
		if(editor == null || editor.document.uri.toString() != uri) {
			return;
		}
		var selections = [];
		var previousEdits = [];
		editor.edit(function(mutator) {
			var _g = 0;
			while(_g < edits.length) {
				var edit = edits[_g];
				++_g;
				var range = new vscode_Range(edit.range.start.line,edit.range.start.character,edit.range.end.line,edit.range.end.character);
				mutator["delete"](range);
				var text = edit.newText;
				var re = new EReg("(?!\\\\)\\$","");
				var pos = null;
				if(re.match(text)) {
					pos = re.matchedPos();
				}
				text = text.replace(re.r,"");
				text = StringTools.replace(text,"\\$","$");
				mutator.insert(range.start,text);
				if(pos != null) {
					var cursorPos = range.start.translate(0,pos.pos);
					var _g1 = 0;
					while(_g1 < previousEdits.length) {
						var prev = previousEdits[_g1];
						++_g1;
						var lines = prev.newText.split("\n");
						cursorPos = cursorPos.translate(prev.range.end.line - prev.range.start.line + (lines.length - 1),prev.range.end.character - prev.range.start.character + lines[lines.length - 1].length);
					}
					selections.push(new vscode_Selection(cursorPos,cursorPos));
				}
				previousEdits.push(edit);
			}
			Vscode.commands.executeCommand("closeParameterHints");
		}).then(function(ok) {
			if(ok && selections.length > 0) {
				editor.selections = selections;
			}
		});
	}
	,showReferences: function(uri,position,locations) {
		var locations1 = locations.map(function(location) {
			var locations2 = vscode_Uri.parse(location.uri);
			var position1 = location.range.start;
			var locations3 = new vscode_Position(position1.line,position1.character);
			var position2 = location.range.end;
			return new vscode_Location(locations2,new vscode_Range(locations3,new vscode_Position(position2.line,position2.character)));
		});
		Vscode.commands.executeCommand("editor.action.showReferences",vscode_Uri.parse(uri),new vscode_Position(position.line,position.character),locations1).then(function(s) {
			console.log("Commands.hx:80:",s);
		},function(s1) {
			console.log("Commands.hx:80:","err: " + s1);
		});
	}
	,runGlobalDiagnostics: function() {
		this.server.client.sendNotification({ method : "vshaxe/runGlobalDiagnostics"});
	}
	,toggleCodeLens: function() {
		var config = Vscode.workspace.getConfiguration("haxe");
		var info = config.inspect("enableCodeLens");
		config.update("enableCodeLens",!this.getCurrentConfigValue(info,config),info.workspaceValue == null);
	}
	,getCurrentConfigValue: function(info,config) {
		var value = info.workspaceValue;
		if(value == null) {
			value = info.globalValue;
		}
		if(value == null) {
			value = info.defaultValue;
		}
		return value;
	}
};
var vshaxe_commands_InitProject = function(context) {
	this.context = context;
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "initProject",$bind(this,this.initProject));
};
vshaxe_commands_InitProject.__name__ = true;
vshaxe_commands_InitProject.prototype = {
	initProject: function() {
		var workspaceRoot = Vscode.workspace.rootPath;
		if(workspaceRoot == null) {
			Vscode.window.showErrorMessage("Please open a folder to set up a Haxe project into");
			return;
		}
		if(Lambda.exists(js_node_Fs.readdirSync(workspaceRoot),function(f) {
			return !StringTools.startsWith(f,".");
		})) {
			Vscode.window.showErrorMessage("To set up sample Haxe project, the workspace must be empty");
			return;
		}
		this.copyRec(this.context.asAbsolutePath("./scaffold/project"),workspaceRoot);
		Vscode.window.setStatusBarMessage("Haxe project scaffolded",2000);
	}
	,copyRec: function(from,to) {
		var loop = null;
		loop = function(src,dst) {
			var fromPath = from + src;
			var toPath = to + dst;
			if(js_node_Fs.statSync(fromPath).isDirectory()) {
				sys_FileSystem.createDirectory(toPath);
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fromPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					loop(src + "/" + file,dst + "/" + file);
				}
			} else {
				sys_io_File.copy(fromPath,toPath);
			}
		};
		loop("","");
	}
};
var vshaxe_dependencyExplorer_DependencyExplorer = function(context,displayArguments,haxeExecutable) {
	this._onDidChangeTreeData = new vscode_EventEmitter();
	this.refreshNeeded = true;
	this.dependencyNodes = [];
	this.relevantHxmls = [];
	var _gthis = this;
	this.context = context;
	this.displayArguments = displayArguments["arguments"];
	this.haxeExecutable = haxeExecutable;
	displayArguments._onDidChangeArguments.event($bind(this,this.onDidChangeDisplayArguments));
	this.onDidChangeTreeData = this._onDidChangeTreeData.event;
	Vscode.window.registerTreeDataProvider("haxe.dependencies",this);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.selectNode",$bind(this,this.selectNode));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.collapseAll",$bind(this,this.collapseAll));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.refresh",$bind(this,this.refresh));
	var hxmlFileWatcher = Vscode.workspace.createFileSystemWatcher("**/*.hxml");
	context.subscriptions.push(hxmlFileWatcher.onDidCreate($bind(this,this.onDidChangeHxml)));
	context.subscriptions.push(hxmlFileWatcher.onDidChange($bind(this,this.onDidChangeHxml)));
	context.subscriptions.push(hxmlFileWatcher.onDidDelete($bind(this,this.onDidChangeHxml)));
	context.subscriptions.push(hxmlFileWatcher);
	context.subscriptions.push((haxeExecutable.get_onDidChangeConfiguration())(function(_) {
		_gthis.refresh();
		return;
	}));
};
vshaxe_dependencyExplorer_DependencyExplorer.__name__ = true;
vshaxe_dependencyExplorer_DependencyExplorer.prototype = {
	onDidChangeHxml: function(uri) {
		var _g = 0;
		var _g1 = this.relevantHxmls;
		while(_g < _g1.length) {
			var hxml = _g1[_g++];
			if(haxe_io_Path.normalize(uri.fsPath) == haxe_io_Path.normalize(hxml)) {
				this.refresh(false);
			}
		}
	}
	,refreshDependencies: function() {
		var newDependencies = vshaxe_dependencyExplorer_DependencyResolver.extractDependencies(this.displayArguments,Vscode.workspace.rootPath);
		this.relevantHxmls = newDependencies.hxmls;
		if(this.dependencies != null && vshaxe_helper_ArrayHelper.equals(this.dependencies.libs,newDependencies.libs) && vshaxe_helper_ArrayHelper.equals(this.dependencies.classPaths,newDependencies.classPaths)) {
			return this.dependencyNodes;
		}
		this.dependencies = newDependencies;
		return this.updateNodes(vshaxe_dependencyExplorer_DependencyResolver.resolveDependencies(newDependencies,this.haxeExecutable));
	}
	,updateNodes: function(dependencyInfos) {
		var newNodes = [];
		var _g = 0;
		while(_g < dependencyInfos.length) {
			var info = [dependencyInfos[_g]];
			++_g;
			if(Lambda.find(newNodes,(function(info1) {
				return function(d) {
					return d.path == info1[0].path;
				};
			})(info)) != null) {
				continue;
			}
			if(this.dependencies != null) {
				var oldNode = Lambda.find(this.dependencyNodes,(function(info2) {
					return function(d1) {
						return d1.path == info2[0].path;
					};
				})(info));
				if(oldNode != null) {
					newNodes.push(oldNode);
					continue;
				}
			}
			var node = this.createNode(info[0]);
			if(node != null) {
				newNodes.push(node);
			}
		}
		return newNodes;
	}
	,createNode: function(info) {
		if(info == null) {
			return null;
		}
		var label = info.name;
		if(info.version != null) {
			label += " (" + info.version + ")";
		}
		return new vshaxe_dependencyExplorer_Node(label,info.path);
	}
	,onDidChangeDisplayArguments: function(displayArguments) {
		this.displayArguments = displayArguments;
		this.refresh();
	}
	,refresh: function(hard) {
		if(hard == null) {
			hard = true;
		}
		if(hard) {
			this.dependencies = null;
			var _g = 0;
			var _g1 = this.dependencyNodes;
			while(_g < _g1.length) _g1[_g++].refresh();
		}
		this.refreshNeeded = true;
		this._onDidChangeTreeData.fire();
	}
	,getTreeItem: function(element) {
		return element;
	}
	,getChildren: function(node) {
		var _gthis = this;
		return new Promise(function(resolve,_) {
			if(_gthis.refreshNeeded) {
				_gthis.dependencyNodes = _gthis.refreshDependencies();
				_gthis.refreshNeeded = false;
			}
			resolve(node == null ? _gthis.dependencyNodes : node.get_children());
		});
	}
	,selectNode: function(node) {
		if(node.isDirectory) {
			node.toggleState();
			this._onDidChangeTreeData.fire();
		} else {
			this.openTextDocument(node);
		}
	}
	,openTextDocument: function(node) {
		var currentTime = new Date().getTime();
		var preview = this.previousSelection == null || this.previousSelection.node != node || currentTime - this.previousSelection.time >= 500;
		Vscode.workspace.openTextDocument(node.path).then(function(document) {
			return Vscode.window.showTextDocument(document,{ preview : preview});
		});
		this.previousSelection = { node : node, time : currentTime};
	}
	,collapseAll: function(node) {
		var _g = 0;
		var _g1 = this.dependencyNodes;
		while(_g < _g1.length) _g1[_g++].collapse();
		this._onDidChangeTreeData.fire();
	}
};
var vshaxe_dependencyExplorer_DependencyResolver = function() { };
vshaxe_dependencyExplorer_DependencyResolver.__name__ = true;
vshaxe_dependencyExplorer_DependencyResolver.extractDependencies = function(args,cwd) {
	var result = { libs : [], classPaths : [], hxmls : []};
	if(args == null) {
		return result;
	}
	var processHxml = function(hxmlFile,cwd1) {
		hxmlFile = vshaxe_helper_PathHelper.absolutize(hxmlFile,cwd1);
		result.hxmls.push(hxmlFile);
		if(hxmlFile == null || !sys_FileSystem.exists(hxmlFile)) {
			return [];
		}
		return vshaxe_helper_HxmlParser.parseFile(js_node_Fs.readFileSync(hxmlFile,{ encoding : "utf8"}));
	};
	var processLines = null;
	processLines = function(lines) {
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			switch(line[1]) {
			case 1:
				var name = line[2];
				if(StringTools.endsWith(name,".hxml")) {
					var processLines1 = processHxml(name,cwd);
					processLines(processLines1);
				}
				break;
			case 2:
				switch(line[2]) {
				case "--cwd":
					var newCwd = line[3];
					if(haxe_io_Path.isAbsolute(newCwd)) {
						cwd = newCwd;
					} else {
						cwd = haxe_io_Path.join([cwd,newCwd]);
					}
					break;
				case "-cp":
					result.classPaths.push(line[3]);
					break;
				case "-lib":
					result.libs.push(line[3]);
					break;
				default:
				}
				break;
			default:
			}
		}
	};
	processLines(vshaxe_helper_HxmlParser.parseArray(args));
	return result;
};
vshaxe_dependencyExplorer_DependencyResolver.resolveDependencies = function(dependencies,haxeExecutable) {
	var paths = [];
	var _g = 0;
	var _g1 = dependencies.libs;
	while(_g < _g1.length) paths = paths.concat(vshaxe_dependencyExplorer_DependencyResolver.resolveHaxelib(_g1[_g++]));
	paths = paths.concat(dependencies.classPaths);
	var infos = paths.map(vshaxe_dependencyExplorer_DependencyResolver.getDependencyInfo).filter(function(info) {
		return info != null;
	});
	var stdLibPath = vshaxe_dependencyExplorer_DependencyResolver.getStandardLibraryPath(haxeExecutable.configuration);
	if(stdLibPath != null && sys_FileSystem.exists(stdLibPath)) {
		infos.push(vshaxe_dependencyExplorer_DependencyResolver.getStandardLibraryInfo(stdLibPath,haxeExecutable.configuration.executable));
	}
	return infos;
};
vshaxe_dependencyExplorer_DependencyResolver.get_haxelibRepo = function() {
	if(vshaxe_dependencyExplorer_DependencyResolver._haxelibRepo == null) {
		vshaxe_dependencyExplorer_DependencyResolver._haxelibRepo = haxe_io_Path.normalize(vshaxe_dependencyExplorer_DependencyResolver.getProcessOutput("haxelib config")[0]);
	}
	return vshaxe_dependencyExplorer_DependencyResolver._haxelibRepo;
};
vshaxe_dependencyExplorer_DependencyResolver.resolveHaxelib = function(lib) {
	var paths = [];
	var _g = 0;
	var _g1 = vshaxe_dependencyExplorer_DependencyResolver.getProcessOutput("haxelib path " + lib);
	while(_g < _g1.length) {
		var potentialPath = haxe_io_Path.normalize(_g1[_g++]);
		if(sys_FileSystem.exists(potentialPath)) {
			paths.push(potentialPath);
		}
	}
	return paths;
};
vshaxe_dependencyExplorer_DependencyResolver.getProcessOutput = function(command) {
	try {
		var oldCwd = process.cwd();
		if(Vscode.workspace.rootPath != null) {
			process.chdir(Vscode.workspace.rootPath);
		}
		var result = js_node_ChildProcess.execSync(command);
		process.chdir(oldCwd);
		var lines = result.toString().split("\n");
		var _g = [];
		var _g1 = 0;
		while(_g1 < lines.length) _g.push(StringTools.trim(lines[_g1++]));
		return _g;
	} catch( e ) {
		return [];
	}
};
vshaxe_dependencyExplorer_DependencyResolver.getDependencyInfo = function(path) {
	var absPath = vshaxe_helper_PathHelper.absolutize(path,Vscode.workspace.rootPath);
	if(!sys_FileSystem.exists(absPath)) {
		return null;
	}
	if(absPath.indexOf(vshaxe_dependencyExplorer_DependencyResolver.get_haxelibRepo()) == -1) {
		if(absPath.indexOf(haxe_io_Path.normalize(Vscode.workspace.rootPath)) == -1) {
			var haxelibInfo = vshaxe_dependencyExplorer_DependencyResolver.searchHaxelibJson(absPath);
			if(haxelibInfo == null) {
				return { name : path, version : null, path : absPath};
			}
			return haxelibInfo;
		}
		return null;
	}
	path = StringTools.replace(absPath,vshaxe_dependencyExplorer_DependencyResolver.get_haxelibRepo() + "/","");
	var segments = path.split("/");
	var name = segments[0];
	var version = segments[1];
	path = "" + vshaxe_dependencyExplorer_DependencyResolver.get_haxelibRepo() + "/" + name;
	if(name != null) {
		name = StringTools.replace(name,",",".");
	}
	if(version != null) {
		path += "/" + version;
		version = StringTools.replace(version,",",".");
	} else {
		version = path;
	}
	if(!sys_FileSystem.exists(path)) {
		return null;
	}
	return { name : name, version : version, path : path};
};
vshaxe_dependencyExplorer_DependencyResolver.searchHaxelibJson = function(path,levels) {
	if(levels == null) {
		levels = 3;
	}
	if(levels <= 0) {
		return null;
	}
	var haxelibFile = haxe_io_Path.join([path,"haxelib.json"]);
	if(sys_FileSystem.exists(haxelibFile)) {
		var content = JSON.parse(js_node_Fs.readFileSync(haxelibFile,{ encoding : "utf8"}));
		if(content.name == null) {
			return null;
		}
		path = haxe_io_Path.normalize(path);
		return { name : content.name, version : path, path : path};
	}
	return vshaxe_dependencyExplorer_DependencyResolver.searchHaxelibJson(haxe_io_Path.join([path,".."]),levels - 1);
};
vshaxe_dependencyExplorer_DependencyResolver.getStandardLibraryPath = function(haxeExecutable) {
	var path = process.env["HAXE_STD_PATH"];
	if(path != null) {
		return path;
	}
	if(Sys.systemName() == "Windows") {
		var path1;
		if(haxeExecutable.isCommand) {
			var exectuable = vshaxe_dependencyExplorer_DependencyResolver.getProcessOutput("where " + haxeExecutable.executable)[0];
			if(exectuable == null) {
				return null;
			}
			path1 = exectuable;
		} else {
			path1 = haxeExecutable.executable;
		}
		return haxe_io_Path.join([haxe_io_Path.directory(path1),"std"]);
	} else {
		var _g = 0;
		var _g1 = ["/usr/local/share/haxe/std/","/usr/local/lib/haxe/std/","/usr/share/haxe/std/","/usr/lib/haxe/std/"];
		while(_g < _g1.length) {
			var path2 = _g1[_g];
			++_g;
			if(sys_FileSystem.exists(path2)) {
				return path2;
			}
		}
	}
	return null;
};
vshaxe_dependencyExplorer_DependencyResolver.getStandardLibraryInfo = function(path,haxeExecutable) {
	var version = "?";
	var result = js_node_ChildProcess.spawnSync(haxeExecutable,["-version"]);
	if(result != null && result.stderr != null) {
		var haxeVersionOutput = result.stderr.toString();
		if(haxeVersionOutput != null) {
			version = StringTools.trim(haxeVersionOutput.split(" ")[0]);
		}
	}
	return { name : "std", path : path, version : version};
};
var vshaxe_dependencyExplorer_Node = function(label,path) {
	vscode_TreeItem.call(this,label);
	this.path = path;
	this.isDirectory = js_node_Fs.statSync(path).isDirectory();
	if(this.isDirectory) {
		this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
	}
	this.command = { command : "haxe." + "dependencies.selectNode", 'arguments' : [this], title : "Open File"};
};
vshaxe_dependencyExplorer_Node.__name__ = true;
vshaxe_dependencyExplorer_Node.__super__ = vscode_TreeItem;
vshaxe_dependencyExplorer_Node.prototype = $extend(vscode_TreeItem.prototype,{
	collapse: function() {
		if(this.collapsibleState != vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.None) {
			this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
		}
	}
	,refresh: function() {
		var _gthis = this;
		if(!this.isDirectory || this.get_children() == null) {
			return;
		}
		var newChildren = [];
		this.forEachChild(function(file,path) {
			var existingNode = null;
			if(_gthis.get_children() != null) {
				existingNode = Lambda.find(_gthis.get_children(),function(node) {
					return node.label == file;
				});
			}
			if(existingNode != null) {
				existingNode.refresh();
				return newChildren.push(existingNode);
			} else {
				return newChildren.push(new vshaxe_dependencyExplorer_Node(file,path));
			}
		});
		this.sortChildren(newChildren);
		this.children = newChildren;
	}
	,toggleState: function() {
		this.collapsibleState = this.collapsibleState == vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed ? vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Expanded : vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
	}
	,get_children: function() {
		if(this.children == null) {
			this.children = this.createChildren();
		}
		return this.children;
	}
	,createChildren: function() {
		if(!this.isDirectory) {
			return [];
		}
		var children = [];
		this.forEachChild(function(file,path) {
			return children.push(new vshaxe_dependencyExplorer_Node(file,path));
		});
		this.sortChildren(children);
		return children;
	}
	,forEachChild: function(f) {
		var _g = 0;
		var _g1 = js_node_Fs.readdirSync(this.path);
		while(_g < _g1.length) {
			var file = _g1[_g];
			++_g;
			if(!this.isExcluded(file)) {
				f(file,"" + this.path + "/" + file);
			}
		}
	}
	,sortChildren: function(children) {
		haxe_ds_ArraySort.sort(children,function(c1,c2) {
			var compare = function(a,b) {
				a = a.toLowerCase();
				b = b.toLowerCase();
				if(a < b) {
					return -1;
				}
				if(a > b) {
					return 1;
				}
				return 0;
			};
			if(c1.isDirectory && c2.isDirectory) {
				return compare(c1.label,c2.label);
			} else if(c1.isDirectory) {
				return -1;
			} else if(c2.isDirectory) {
				return 1;
			} else {
				return compare(c1.label,c2.label);
			}
		});
	}
	,isExcluded: function(file) {
		if(!(file == ".git" || file == ".svn" || file == ".hg" || file == "CVS")) {
			return file == ".DS_Store";
		} else {
			return true;
		}
	}
});
var vshaxe_display_DisplayArguments = function(context) {
	this.context = context;
	this.providers = new haxe_ds_StringMap();
	this._onDidChangeArguments = new vscode_EventEmitter();
	context.subscriptions.push(this._onDidChangeArguments);
	this.statusBarItem = Vscode.window.createStatusBarItem(vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$.Left,11);
	this.statusBarItem.tooltip = "Select Haxe Completion Provider";
	this.statusBarItem.command = "haxe." + "selectDisplayArgumentsProvider";
	context.subscriptions.push(this.statusBarItem);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "selectDisplayArgumentsProvider",$bind(this,this.selectProvider));
	this.updateStatusBarItem();
};
vshaxe_display_DisplayArguments.__name__ = true;
vshaxe_display_DisplayArguments.prototype = {
	registerProvider: function(name,provider) {
		var _gthis = this;
		var _this = this.providers;
		if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
			throw new Error("Display arguments provider `" + name + "` is already registered.");
		}
		var _this1 = this.providers;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,provider);
		} else {
			_this1.h[name] = provider;
		}
		var current = this.context.workspaceState.get("haxe." + "displayArgumentsProviderName");
		if(current == null || current == name) {
			this.setCurrentProvider(name,false);
		} else {
			this.updateStatusBarItem();
		}
		return new vscode_Disposable(function() {
			_gthis.providers.remove(name);
			if(name == _gthis.currentProvider) {
				_gthis.setCurrentProvider(null,false);
			}
			_gthis.updateStatusBarItem();
		});
	}
	,selectProvider: function() {
		var _gthis = this;
		var _g = [];
		var name = this.providers.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this = this.providers;
			_g.push({ label : name1, description : (__map_reserved[name1] != null ? _this.getReserved(name1) : _this.h[name1]).description});
		}
		if(_g.length == 0) {
			Vscode.window.showErrorMessage("No Haxe completion providers registered.");
			return;
		}
		vshaxe_helper_ArrayHelper.moveToStart(_g,function(item) {
			return item.label == _gthis.currentProvider;
		});
		Vscode.window.showQuickPick(_g,{ placeHolder : "Select Haxe Completion Provider"}).then(function(item1) {
			if(item1 != null) {
				_gthis.setCurrentProvider(item1.label,true);
			}
			return;
		});
	}
	,setCurrentProvider: function(name,persist) {
		if(this.currentProvider != null) {
			var key = this.currentProvider;
			var _this = this.providers;
			var provider = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
			if(provider != null) {
				provider.deactivate();
			}
		}
		this.currentProvider = name;
		if(name != null) {
			var _this1 = this.providers;
			var provider1 = __map_reserved[name] != null ? _this1.getReserved(name) : _this1.h[name];
			if(provider1 != null) {
				provider1.activate($bind(this,this.provideArguments));
			}
		}
		if(persist) {
			this.context.workspaceState.update("haxe." + "displayArgumentsProviderName",name);
		}
		this.updateStatusBarItem();
	}
	,provideArguments: function(newArguments) {
		if(!vshaxe_helper_ArrayHelper.equals(newArguments,this["arguments"])) {
			this["arguments"] = newArguments;
			this._onDidChangeArguments.fire(newArguments);
		}
	}
	,updateStatusBarItem: function() {
		if(this.currentProvider == null) {
			this.statusBarItem.hide();
			return;
		}
		var label = this.currentProvider;
		var color = null;
		var key = this.currentProvider;
		var _this = this.providers;
		if((__map_reserved[key] != null ? _this.getReserved(key) : _this.h[key]) == null) {
			label = "" + this.currentProvider + " (not available)";
			color = vshaxe_display_DisplayArguments.statusBarWarningThemeColor;
		}
		this.statusBarItem.color = color;
		this.statusBarItem.text = "$(gear) " + label;
		this.statusBarItem.show();
	}
};
var vshaxe_display_HaxeDisplayArgumentsProvider = function(context,api,hxmlDiscovery) {
	this.description = "Project using haxe.displayConfigurations or HXML files (built-in)";
	var _gthis = this;
	this.context = context;
	this.api = api;
	this.hxmlDiscovery = hxmlDiscovery;
	this.statusBarItem = Vscode.window.createStatusBarItem(vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$.Left,10);
	this.statusBarItem.tooltip = "Select Haxe Configuration";
	this.statusBarItem.command = "haxe." + "selectDisplayConfiguration";
	context.subscriptions.push(this.statusBarItem);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "selectDisplayConfiguration",$bind(this,this.selectConfiguration));
	context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.refresh();
		return;
	}));
	hxmlDiscovery._onDidChangeFiles.event(function(_1) {
		_gthis.refresh();
		return;
	});
	this.refresh();
};
vshaxe_display_HaxeDisplayArgumentsProvider.__name__ = true;
vshaxe_display_HaxeDisplayArgumentsProvider.prototype = {
	updateConfigurations: function() {
		var configs = Vscode.workspace.getConfiguration("haxe").get("displayConfigurations");
		if(configs == null) {
			configs = [];
		}
		this.configurations = [];
		var _g1 = 0;
		var _g = configs.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.configurations.push({ kind : vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Configured(i), args : configs[i]});
		}
		var _g2 = 0;
		var _g11 = this.hxmlDiscovery.files;
		while(_g2 < _g11.length) {
			var hxmlFile = _g11[_g2];
			++_g2;
			var hxmlConfig = [[hxmlFile]];
			if(!Lambda.exists(configs,(function(hxmlConfig1) {
				return function(config) {
					return vshaxe_helper_ArrayHelper.equals(config,hxmlConfig1[0]);
				};
			})(hxmlConfig))) {
				this.configurations.push({ kind : vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Discovered(hxmlFile), args : hxmlConfig[0]});
			}
		}
	}
	,activate: function(provideArguments) {
		this.provideArguments = provideArguments;
		var config = this.getCurrent();
		this.updateStatusBarItem(config);
		if(this.provideArguments != null) {
			this.provideArguments(config == null ? [] : config.args);
		}
	}
	,deactivate: function() {
		this.provideArguments = null;
		this.updateStatusBarItem(null);
	}
	,selectConfiguration: function() {
		var _gthis = this;
		if(this.configurations.length == 0) {
			Vscode.window.showErrorMessage("No Haxe configurations are available. Please provide the haxe.displayConfigurations setting.",{ title : "Edit settings"}).then(function(button) {
				if(button == null) {
					return;
				}
				Vscode.workspace.getConfiguration("haxe").update("displayConfigurations",[],false).then(function(_) {
					Vscode.workspace.openTextDocument(Vscode.workspace.rootPath + "/.vscode/settings.json").then(function(document) {
						return Vscode.window.showTextDocument(document);
					});
					return;
				});
			});
			return;
		}
		var items = [];
		var _g = 0;
		var _g1 = this.configurations;
		while(_g < _g1.length) {
			var conf = _g1[_g];
			++_g;
			var label;
			var desc;
			var _g2 = conf.kind;
			switch(_g2[1]) {
			case 0:
				label = conf.args.join(" ");
				desc = "from settings.json";
				break;
			case 1:
				label = _g2[2];
				desc = "auto-discovered";
				break;
			}
			items.push({ label : label, description : desc, config : conf});
		}
		var current = this.getCurrent();
		if(current != null) {
			vshaxe_helper_ArrayHelper.moveToStart(items,function(item) {
				return item.config == current;
			});
		}
		Vscode.window.showQuickPick(items,{ matchOnDescription : true, placeHolder : "Select Haxe Configuration"}).then(function(choice) {
			if(choice == null || choice.config == current) {
				return;
			}
			_gthis.setCurrent(choice.config);
		});
	}
	,getCurrent: function() {
		var selection = this.context.workspaceState.get("haxe." + "displayConfigurationIndex",0);
		var _g = 0;
		var _g1 = this.configurations;
		while(_g < _g1.length) {
			var conf = _g1[_g];
			++_g;
			var _g2 = conf.kind;
			switch(_g2[1]) {
			case 0:
				if(_g2[2] == selection) {
					return conf;
				}
				break;
			case 1:
				if(_g2[2] == selection) {
					return conf;
				}
				break;
			default:
			}
		}
		return null;
	}
	,setCurrent: function(config) {
		var _g = config.kind;
		var tmp;
		switch(_g[1]) {
		case 0:
			tmp = _g[2];
			break;
		case 1:
			tmp = _g[2];
			break;
		}
		this.context.workspaceState.update("haxe." + "displayConfigurationIndex",tmp);
		this.updateStatusBarItem(config);
		if(this.provideArguments != null) {
			this.provideArguments(config == null ? [] : config.args);
		}
	}
	,refresh: function() {
		this.updateConfigurations();
		this.updateDisplayArgumentsProviderRegistration();
		var config = this.getCurrent();
		if(config == null && this.configurations.length > 0) {
			config = this.configurations[0];
			this.setCurrent(config);
		} else {
			this.updateStatusBarItem(config);
			if(this.provideArguments != null) {
				this.provideArguments(config == null ? [] : config.args);
			}
		}
	}
	,updateDisplayArgumentsProviderRegistration: function() {
		var isActive = this.configurations.length > 0;
		if(isActive && this.providerDisposable == null) {
			this.providerDisposable = this.api.registerDisplayArgumentsProvider("Haxe",this);
		} else if(!isActive && this.providerDisposable != null) {
			this.providerDisposable.dispose();
			this.providerDisposable = null;
		}
	}
	,updateStatusBarItem: function(config) {
		if(this.provideArguments != null && config != null) {
			var label = config.args.join(" ");
			if(label.length > 50) {
				label = StringTools.rtrim(HxOverrides.substr(label,0,47)) + "...";
			}
			this.statusBarItem.text = label;
			this.statusBarItem.show();
			return;
		}
		this.statusBarItem.hide();
	}
};
var vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind = { __ename__ : true, __constructs__ : ["Configured","Discovered"] };
vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Configured = function(index) { var $x = ["Configured",0,index]; $x.__enum__ = vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind; $x.toString = $estr; return $x; };
vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Discovered = function(id) { var $x = ["Discovered",1,id]; $x.__enum__ = vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind; $x.toString = $estr; return $x; };
var vshaxe_helper_ArrayHelper = function() { };
vshaxe_helper_ArrayHelper.__name__ = true;
vshaxe_helper_ArrayHelper.equals = function(a1,a2) {
	if(a1 == null && a2 == null) {
		return true;
	}
	if(a1 == null && a2 != null) {
		return false;
	}
	if(a1 != null && a2 == null) {
		return false;
	}
	if(a1.length != a2.length) {
		return false;
	}
	var _g1 = 0;
	var _g = a1.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(a1[i] != a2[i]) {
			return false;
		}
	}
	return true;
};
vshaxe_helper_ArrayHelper.moveToStart = function(array,f) {
	var element = Lambda.find(array,f);
	if(element != null) {
		HxOverrides.remove(array,element);
		array.unshift(element);
	}
};
var vshaxe_helper_ContextHelper = function() { };
vshaxe_helper_ContextHelper.__name__ = true;
vshaxe_helper_ContextHelper.registerHaxeCommand = function(context,command,callback) {
	context.subscriptions.push(Vscode.commands.registerCommand(command,callback));
};
var vshaxe_helper_HaxeExecutable = function(context) {
	var _gthis = this;
	this.updateConfig(Vscode.workspace.getConfiguration("haxe").get("executable"));
	this._onDidChangeConfiguration = new vscode_EventEmitter();
	context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.refresh();
		return;
	}));
};
vshaxe_helper_HaxeExecutable.__name__ = true;
vshaxe_helper_HaxeExecutable.isSame = function(oldConfig,newConfig) {
	if(oldConfig.path != newConfig.path) {
		return false;
	}
	var oldKeys = Reflect.fields(oldConfig.env);
	var newKeys = Reflect.fields(newConfig.env);
	if(oldKeys.length != newKeys.length) {
		return false;
	}
	var _g = 0;
	while(_g < newKeys.length) {
		var key = newKeys[_g];
		++_g;
		if(oldConfig.env[key] != newConfig.env[key]) {
			return false;
		}
		HxOverrides.remove(oldKeys,key);
	}
	if(oldKeys.length > 0) {
		return false;
	}
	return true;
};
vshaxe_helper_HaxeExecutable.prototype = {
	get_onDidChangeConfiguration: function() {
		return this._onDidChangeConfiguration.event;
	}
	,isConfigured: function() {
		var executableSetting = Vscode.workspace.getConfiguration("haxe").inspect("executable");
		if(executableSetting.workspaceValue == null) {
			return executableSetting.globalValue != null;
		} else {
			return true;
		}
	}
	,refresh: function() {
		var oldConfig = this.rawConfig;
		this.updateConfig(Vscode.workspace.getConfiguration("haxe").get("executable"));
		if(!vshaxe_helper_HaxeExecutable.isSame(oldConfig,this.rawConfig)) {
			this._onDidChangeConfiguration.fire(this.configuration);
		}
	}
	,updateConfig: function(input) {
		var executable = "haxe";
		var env = { };
		var merge = function(conf) {
			if(typeof(conf) == "string") {
				executable = conf;
			} else {
				var conf1 = conf;
				if(conf1.path != null) {
					executable = conf1.path;
				}
				if(conf1.env != null) {
					env = conf1.env;
				}
			}
		};
		if(input != null) {
			merge(input);
			var systemConfig = Reflect.field(input,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
			if(systemConfig != null) {
				merge(systemConfig);
			}
		}
		var isCommand = false;
		if(!haxe_io_Path.isAbsolute(executable)) {
			var absolutePath = vshaxe_helper_PathHelper.absolutize(executable,Vscode.workspace.rootPath);
			if(sys_FileSystem.exists(absolutePath) && !js_node_Fs.statSync(absolutePath).isDirectory()) {
				executable = absolutePath;
			} else {
				isCommand = true;
			}
		}
		this.rawConfig = input;
		this.configuration = { executable : executable, isCommand : isCommand, env : env};
	}
};
var vshaxe_helper_HxmlLine = { __ename__ : true, __constructs__ : ["Comment","Simple","Param"] };
vshaxe_helper_HxmlLine.Comment = function(comment) { var $x = ["Comment",0,comment]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; };
vshaxe_helper_HxmlLine.Simple = function(name) { var $x = ["Simple",1,name]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; };
vshaxe_helper_HxmlLine.Param = function(name,value) { var $x = ["Param",2,name,value]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; };
var vshaxe_helper_HxmlParser = function() { };
vshaxe_helper_HxmlParser.__name__ = true;
vshaxe_helper_HxmlParser.unquote = function(s) {
	var len = s.length;
	if(len > 0 && s.charCodeAt(0) == 34 && s.charCodeAt(len - 1) == 34) {
		return s.substring(1,len - 1);
	} else {
		return s;
	}
};
vshaxe_helper_HxmlParser.parseFile = function(src) {
	var result = [];
	var srcLines = new EReg("[\n\r]+","g").split(src);
	var _g = 0;
	while(_g < srcLines.length) {
		var line = srcLines[_g];
		++_g;
		line = vshaxe_helper_HxmlParser.unquote(StringTools.trim(line));
		if(line.length == 0) {
			continue;
		}
		if(StringTools.startsWith(line,"#")) {
			result.push(vshaxe_helper_HxmlLine.Comment(StringTools.ltrim(HxOverrides.substr(line,1,null))));
		} else if(StringTools.startsWith(line,"-")) {
			var idx = line.indexOf(" ");
			if(idx == -1) {
				result.push(vshaxe_helper_HxmlLine.Simple(line));
			} else {
				result.push(vshaxe_helper_HxmlLine.Param(HxOverrides.substr(line,0,idx),vshaxe_helper_HxmlParser.unquote(StringTools.ltrim(HxOverrides.substr(line,idx,null)))));
			}
		} else {
			result.push(vshaxe_helper_HxmlLine.Simple(line));
		}
	}
	return result;
};
vshaxe_helper_HxmlParser.parseToArgs = function(src) {
	var result = [];
	var _g = 0;
	var _g1 = vshaxe_helper_HxmlParser.parseFile(src);
	while(_g < _g1.length) {
		var line = _g1[_g];
		++_g;
		switch(line[1]) {
		case 0:
			break;
		case 1:
			result.push(line[2]);
			break;
		case 2:
			result.push(line[2]);
			result.push(line[3]);
			break;
		}
	}
	return result;
};
vshaxe_helper_HxmlParser.parseArray = function(args) {
	var result = [];
	var flag = null;
	var _g = 0;
	while(_g < args.length) {
		var arg = args[_g];
		++_g;
		if(StringTools.startsWith(arg,"-")) {
			if(flag != null) {
				result.push(vshaxe_helper_HxmlLine.Simple(flag));
				flag = null;
			}
			flag = arg;
		} else if(flag != null) {
			result.push(vshaxe_helper_HxmlLine.Param(flag,arg));
			flag = null;
		} else {
			result.push(vshaxe_helper_HxmlLine.Simple(arg));
		}
	}
	if(flag != null) {
		result.push(vshaxe_helper_HxmlLine.Simple(flag));
	}
	return result;
};
var vshaxe_helper_PathHelper = function() { };
vshaxe_helper_PathHelper.__name__ = true;
vshaxe_helper_PathHelper.absolutize = function(path,cwd) {
	return haxe_io_Path.normalize(haxe_io_Path.isAbsolute(path) ? path : haxe_io_Path.join([cwd,path]));
};
vshaxe_helper_PathHelper.relativize = function(path,cwd) {
	path = haxe_io_Path.normalize(path);
	cwd = haxe_io_Path.normalize(cwd) + "/";
	var segments = path.split(cwd);
	segments.shift();
	return segments.join(cwd);
};
var vshaxe_server_LanguageClient = require("vscode-languageclient").LanguageClient;
var vshaxe_server_LanguageServer = function(context,haxeExecutable,displayArguments) {
	this.progresses = new haxe_ds_IntMap();
	var _gthis = this;
	this.context = context;
	this.displayArguments = displayArguments;
	this.haxeExecutable = haxeExecutable;
	this.prepareDisplayServerConfig();
	context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.refreshDisplayServerConfig();
		return;
	}));
	context.subscriptions.push((haxeExecutable.get_onDidChangeConfiguration())(function(_1) {
		_gthis.refreshDisplayServerConfig();
		return;
	}));
	context.subscriptions.push(Vscode.window.onDidChangeActiveTextEditor($bind(this,this.onDidChangeActiveTextEditor)));
};
vshaxe_server_LanguageServer.__name__ = true;
vshaxe_server_LanguageServer.prototype = {
	refreshDisplayServerConfig: function() {
		if(this.prepareDisplayServerConfig() && this.client != null) {
			this.client.sendNotification({ method : "vshaxe/didChangeDisplayServerConfig"},this.displayServerConfig);
		}
	}
	,onDidChangeActiveTextEditor: function(editor) {
		if(editor != null && editor.document.languageId == "haxe") {
			var tmp = this.client;
			var tmp1 = editor.document.uri.toString();
			tmp.sendNotification({ method : "vshaxe/didChangeActiveTextEditor"},{ uri : tmp1});
		}
	}
	,start: function() {
		var _gthis = this;
		var serverModule = this.context.asAbsolutePath("./server_wrapper.js");
		var serverOptions = { run : { module : serverModule, options : { env : process.env}}, debug : { module : serverModule, options : { env : process.env, execArgv : ["--nolazy","--debug=6004"]}}};
		this.hxFileWatcher = Vscode.workspace.createFileSystemWatcher("**/*.hx",false,true,false);
		this.client = new vshaxe_server_LanguageClient("haxe","Haxe",serverOptions,{ documentSelector : "haxe", synchronize : { configurationSection : "haxe", fileEvents : this.hxFileWatcher}, initializationOptions : { displayArguments : this.displayArguments["arguments"], displayServerConfig : this.displayServerConfig}});
		this.client.logFailedRequest = function(type,error) {
			_gthis.client.warn("Request " + type.method + " failed.",error);
		};
		var argumentsChanged = false;
		var argumentChangeListenerDisposable = this.displayArguments._onDidChangeArguments.event(function(_) {
			argumentsChanged = true;
			return argumentsChanged;
		});
		this.client.onReady().then(function(_1) {
			_gthis.client.outputChannel.appendLine("Haxe language server started");
			argumentChangeListenerDisposable.dispose();
			if(argumentsChanged) {
				_gthis.client.sendNotification({ method : "vshaxe/didChangeDisplayArguments"},{ 'arguments' : _gthis.displayArguments["arguments"]});
			}
			argumentChangeListenerDisposable = _gthis.displayArguments._onDidChangeArguments.event(function($arguments) {
				_gthis.client.sendNotification({ method : "vshaxe/didChangeDisplayArguments"},{ 'arguments' : $arguments});
				return;
			});
			_gthis.context.subscriptions.push(_gthis.hxFileWatcher.onDidCreate(function(uri) {
				var editor = Vscode.window.activeTextEditor;
				if(editor == null || editor.document.uri.fsPath != uri.fsPath) {
					return;
				}
				if(editor.document.getText(new vscode_Range(0,0,0,1)).length > 0) {
					return;
				}
				_gthis.client.sendRequest({ method : "vshaxe/determinePackage"},{ fsPath : uri.fsPath}).then(function(result) {
					if(result.pack == "") {
						return;
					}
					editor.edit(function(edit) {
						edit.insert(new vscode_Position(0,0),"package " + result.pack + ";\n\n");
					});
				});
			}));
			_gthis.context.subscriptions.push(_gthis.hxFileWatcher);
			_gthis.client.onNotification({ method : "vshaxe/progressStart"},$bind(_gthis,_gthis.startProgress));
			_gthis.client.onNotification({ method : "vshaxe/progressStop"},$bind(_gthis,_gthis.stopProgress));
		});
		var clientDisposable = this.client.start();
		this.disposable = new vscode_Disposable(function() {
			clientDisposable.dispose();
			argumentChangeListenerDisposable.dispose();
		});
		this.context.subscriptions.push(this.disposable);
	}
	,prepareDisplayServerConfig: function() {
		var path = this.haxeExecutable.configuration.executable;
		var env = this.haxeExecutable.configuration.env;
		var haxeConfig = Vscode.workspace.getConfiguration("haxe");
		var $arguments = haxeConfig.get("displayServer.arguments",[]);
		if(!this.haxeExecutable.isConfigured()) {
			var displayServerConfig = haxeConfig.get("displayServer");
			var merge = function(conf) {
				if(conf.haxePath != null) {
					path = conf.haxePath;
				}
				if(conf.env != null) {
					env = conf.env;
				}
			};
			if(displayServerConfig != null) {
				merge(displayServerConfig);
				var systemConfig = Reflect.field(displayServerConfig,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
				if(systemConfig != null) {
					merge(systemConfig);
				}
			}
		}
		this.displayServerConfig = { path : path, env : env, 'arguments' : $arguments};
		var oldSerialized = this.displayServerConfigSerialized;
		this.displayServerConfigSerialized = JSON.stringify(this.displayServerConfig);
		return this.displayServerConfigSerialized != oldSerialized;
	}
	,startProgress: function(data) {
		var _gthis = this;
		Vscode.window.withProgress({ location : vscode__$ProgressLocation_ProgressLocation_$Impl_$.Window, title : data.title},function(_) {
			return new Promise(function(resolve,_1) {
				_gthis.progresses.h[data.id] = function() {
					resolve(null);
				};
			});
		});
	}
	,stopProgress: function(data) {
		var stop = this.progresses.h[data.id];
		if(stop != null) {
			this.progresses.remove(data.id);
			stop();
		}
	}
	,restart: function() {
		if(this.client != null && this.client.outputChannel != null) {
			this.client.outputChannel.dispose();
		}
		if(this.disposable != null) {
			HxOverrides.remove(this.context.subscriptions,this.disposable);
			this.disposable.dispose();
			this.disposable = null;
		}
		if(this.hxFileWatcher != null) {
			HxOverrides.remove(this.context.subscriptions,this.hxFileWatcher);
			this.hxFileWatcher.dispose();
			this.hxFileWatcher = null;
		}
		var stop = this.progresses.iterator();
		while(stop.hasNext()) (stop.next())();
		this.progresses = new haxe_ds_IntMap();
		this.start();
	}
};
var vshaxe_tasks_HxmlTaskProvider = function(hxmlDiscovery,haxeExecutable) {
	this.hxmlDiscovery = hxmlDiscovery;
	this.haxeExecutable = haxeExecutable;
	Vscode.workspace.registerTaskProvider("hxml",this);
};
vshaxe_tasks_HxmlTaskProvider.__name__ = true;
vshaxe_tasks_HxmlTaskProvider.prototype = {
	provideTasks: function(token) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.hxmlDiscovery.files;
		while(_g1 < _g2.length) {
			var file = _g2[_g1];
			++_g1;
			var task = new vscode_Task({ type : "hxml", file : file},file,"haxe",new vscode_ProcessExecution(this.haxeExecutable.configuration.executable,[file],{ env : this.haxeExecutable.configuration.env}),"$haxe");
			task.group = vscode_TaskGroup.Build;
			_g.push(task);
		}
		return _g;
	}
	,resolveTask: function(task,token) {
		return task;
	}
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = ["Date"];
var __map_reserved = {};
sys_io_File.copyBuf = new js_node_buffer_Buffer(65536);
vshaxe_display_DisplayArguments.statusBarWarningThemeColor = new vscode_ThemeColor("errorForeground");
vshaxe_helper_HaxeExecutable.SYSTEM_KEY = (function($this) {
	var $r;
	switch(Sys.systemName()) {
	case "Mac":
		$r = "osx";
		break;
	case "Windows":
		$r = "windows";
		break;
	default:
		$r = "linux";
	}
	return $r;
}(this));
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
